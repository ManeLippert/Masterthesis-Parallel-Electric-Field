\section{$\Epar$ Field Equation}
\label{sec:implementationFieldEpar}

Since the code is capable of parallization the inserted code is written to use the OpenMPI libary. This will from now on uncomment. Further subtile changes or import statements will be uncommented since most of them are just following the eastablished stucture for $\Apar$ and add them for $\Epar$ into the code as well. The reader is referred to the branch in bibucket\cite{FeatureEparBitbucket} for more in depth documentation on the process and implementation.

\subsubsection*{Feature Switch}

For the calculation for $\Epar$ a new switch has to be added into \code{control.f90} which relates to the parameter \code{nlepar}. By default, \code{nlepar} is set off. Since, the implementation of $\Epar$ is electromagnetic it is necessary to activate the switch for $\Apar$ as well, i.e. \code{nlapar}. All upcoming changes in the code can only be accessed if \code{nlepar} is set to \code{.true.} which gets implemented with an if statement.

\subsubsection*{Identifiers \code{iepar} and \code{iepar\_ga}}

In the next step the identifieres for the $\Epar$ and $\gaEpar$ will be defined in \code{dist.f90}. These identifieres makes it possible to access only $\Epar$ and $\gaEpar$ in teh solution \code{fdisi} with the use of the index function from the module \code{index\_function}. The definition of the identifieres follows the already established scheme with the name \code{iepar} and \code{iepar\_ga} although 
\begin{itemize}
    \item \code{iepar = 4 + IS\_3D\_FIELD = 12} with \code{IS\_3D\_FIELD = 2\ast\ast 3 = 8} and
    \item \code{iepar\_ga = 4 + IS\_GYROAVG\_FIELD = 36} with \code{IS\_GYROAVG\_FIELD = 2\ast\ast 5 = 32}.
\end{itemize}
It was checked, if the new indentifiers are not used from the existing implementation. \bigskip

\subsubsection*{Definition of Grid Points and Ghost Cells}

To continue the implementation, the grid points of $\Epar$ gets defined as well as the ghost cells of $\Epar$. 
\lstinputlisting[language=Fortran, firstline=621, lastline=632]{../gkw/src/dist.f90}
Here, \code{number\_of\_fields} refers to the total number of fields that gets calculated, \code{n\_epar} to the start of the grid points for $\Epar$ in \code{fdisi}, \code{nelem\_epar} for the amount of grid points and \code{nfields} for all grid points for the fields calculation, i.e. additonal and regular fields. Additionally, the maximum number of grid points for $\Epar$ (\code{nf}) gets added to the total number of grid points \code{ntot} with \code{ntot = ntot + nf}, where \code{nf} equals the number of grid points for the distribution function $\df$. The same definition will be also made for the gyroaveraged field $\gaEpar$ as listed bellow. The general scheme is the same as for $\Epar$.
\lstinputlisting[language=Fortran, firstline=685, lastline=697]{../gkw/src/dist.f90}
\bigskip

It is necessary to mentioned that the implementation of the grid points for $\Epar$ results in an compliation error of {\gkw}. The error is strongly connected to the variable \code{field\_id} which is used to create an quick look up array for the fields in the function \code{get\_field\_index\_lookup\_array} in \code{diagnos\_growth\_freq} and \code{diagnos\_timetrace} as well as in a code section in the subroutine \code{normalise\_init} in the module \code{normalise}. The main problem in the function \code{get\_field\_index\_lookup\_array} is, that the size of the array \code{field\_id} gets allocated with the variable \code{number\_of\_fields} form module \code{dist}. The incremtation of \code{number\_of\_fields} by $\Epar$ results in an {\gkw} error called "bad identifier". Adding $\Epar$ into the function solves the issue. In the subroutine \code{normalise\_init} the code for $\Epar$ and $\gaEpar$ has to be added as well as the allocated size of \code{field\_id} increased by two. At the end in the subroutine \code{calc\_phase} from the module \code{diagnos\_growth\_freq} the size of the array \code{field\_id} has also be incremented by one to prevent any bad identifiers.

\newpage

\subsection*{Calculation of $\Epar$}

Before the implementation for the calculation of $\Epar$ gets discussed it is necessary to talk about the scheme of the calculation. As stated in Equation (\ref{eq:fieldElectricLocalNorm}) is the right-hand side of the Vlasov equation $\rhs$ necessary for the calculation of $\Epar$. Now, if one takes a closer look at Equations (\ref{eq:modifiedDistrubutionFunction}) and (\ref{eq:gyrocenterDeltafSubVlasovReduced}) it can be derived that
\begin{gather}
    \frac{\partial g}{\Dt} = \rhs~,
    \label{eq:rightHandSide}
\end{gather}
where $g$ is the modified distribution. Since {\gkw} has already implemented $\partial_t g$ as \code{rhs} (right-hand side) and the Vlasov equation with the modified distribution function [Eq (\ref{eq:modifiedGyrocenterDeltafSubVlasov})] has only one additional term containing $g$, which is nonlinear, i.e. ignored in linear cases, \code{rhs} will be used as the right-hand side of the Vlasov equation in the calculation of $\Epar$. In the next step the numerical scheme for every Runge Kutta step ($i \rightarrow i+1$) has to be considered. Figure \ref{fig:numericalSchemeEpar} gives an illustration of the scheme.

\inputgraphicsHere{../pictures/methods/Numerical-Scheme-Epar}{
	Numerical scheme used to calculate the induced eletric field $\Epar$ in {\gkw}.
}{fig:numericalSchemeEpar}

As visible, the order of calculations is important in the numerical scheme, i.e. first calculate the right-hand side of the Vlasov equation $\rhs$ and afterwards the induced electric field $\Epar$. To achieve this structure the calculation of $\Epar$ gets performed in \code{calculate\_rhs} from the module \code{exp\_integration}. For that, the following code lines get added in \code{calculate\_rhs}

\lstinputlisting[language=Fortran, firstline=924, lastline=943]{../gkw/src/exp_integration.F90}

To ensure that the right Runge Kutta step for the calculatation of $\Epar$ is used, the following lines have to be adjusted in the subroutine \code{advance\_large\_step\_explicit} in the same module.

\lstinputlisting[language=Fortran, firstline=231, lastline=243]{../gkw/src/exp_integration.F90}

Note that, before the implementation of $\Epar$ feature, \code{calculate\_fields} gets called for local simulations, but since the calculation of $\Epar$ requires the calculation of the right-hand side $\rhs$, which calculates the regular fields already in the subroutine \code{calculate\_rhs}, the call for \code{calculate\_fields} can be neglected if $\Epar$ gets calculated.

The calculation of $\Epar$ itself gets performed by \code{calculate\_additonal\_fields} from the module \code{fields}. The subroutine is listed below

\lstinputlisting[language=Fortran, firstline=329, lastline=417]{../gkw/src/fields.F90}

This subroutine has the same structure as \code{calculate\_fields} with two major differences.
No tearing modes are implemented yet and if tearing modes are activated, a warning gets printed to the console. \code{rhs} and \code{DTIM} as additonal argument for the subroutine. The use of \code{rhs} was already discussed at the beginning of this section but the variable \code{rhs}, which gets communticated in \code{calculate\_rhs} is not already the right right-hand side needed for the calculation of $\Epar$. \code{rhs} is a product of \code{rhs} and the time step \code{deltatime}. This is due to the Runge Kutta scheme for the calculatation of the distribution function $g$. To ensure that the "pure" right-hand side $\rhs$ will be used for $\Epar$ the argument \code{DTIM} in \code{calculate\_additonal\_fields} is used to divide \code{rhs} by \code{DTIM}, which is \code{deltatime} from \code{calculate\_rhs}. \bigskip

In {\gkw} the calculation of the $\Epar$ field gets performed in two steps:
\begin{enumerate}
    \item [(1)] Matrix vector multiplication of the matrix containing the integral part of $\Epar$ with the "pure" right-hand side array \code{rhs/DTIM} \\
                \code{fdisi = mat\_add\_field\_int \ast~(rhs / DTIM) }
    \item [(2)] Division of the matrix containing the diagonal part of $\Epar$ \\
                \code{fdisi = fdisi / mat\_add\_field\_diag}.
\end{enumerate}
Both operations gets saved in the solution array \code{fdisi}. The integral part (\code{faraday\_int}) and the diagonal part (\code{faraday\_dia}) gets extracted from Equation (\ref{eq:fieldElectricLocalNorm}) and defined as
\begin{gather}
    \begin{aligned}
        \texttt{faraday\_int} &= - 2\pi\BN \betaref \spec{\sum} \spec{Z} \specR{n} \specthR{v} \ints \dvparN \dmuN ~ \vparN J_0(\kperp \spec{\rho})\\
        \texttt{faraday\_dia} &= \left(\kperpN^2 + \betaref \spec{\sum} \frac{\spec{Z^2}\specR{n}}{\specR{m}} \Gamma_0(\spec{b}) e^{-\specN{\cfen}/\specR{T}} \right)~.
    \end{aligned}
\end{gather}
\code{faraday\_int} and \code{faraday\_dia} both are defined in the module \code{linear\_terms} in two seperate subroutions given below

\lstinputlisting[language=Fortran, firstline=3211, lastline=3267]{../gkw/src/linear_terms.f90}

\lstinputlisting[language=Fortran, firstline=3699, lastline=3793]{../gkw/src/linear_terms.f90}

Note that, the $2\pi$ factor in \code{faraday\_int} is already included in the array \code{intmu} \cite{GKWManual} and will be ignored. Additionally, in \code{faraday\_dia} a new calculation for the $\Gamma_0(b)$ [Eq (\ref{eq:integralBesselfunction})] was introduced from Yann Camenen in February 2023. The integral part will get added to the matrix \code{mat\_add\_field\_int} and the diagonal part in \code{mat\_add\_field\_diag}. Both matrices are defined in \code{matdat}. The size of the matrices gets defined with \code{nelem\_additional\_fields} in \code{dist} with the same method as \code{nelem\_regular\_fields}. It is important to mention, that the declaration has to be after the definition of grid points and ghost cells for the additional fields. Also, during the optimizition of the number of elements for \code{mat\_add\_field\_int} and \code{mat\_add\_field\_diag} it was found that the \code{nelem\_additional\_fields} can not be further reduced. It seems like the field matrices for the additional fields has to account the number of elements for regular field matrices as well. To investigate the matrices, they got added to the diagnostic module \code{diagnos\_matrix} which handles the output.

\subsubsection*{Diagnostic for $\Epar$}

To extract $\Epar$ from \code{fdisi} the subroutine \code{get\_epar} in \code{dist.f90} is needed and is given in greater detail below
\lstinputlisting[language=Fortran, firstline=1469, lastline=1511]{../gkw/src/dist.f90}

In general the given subroutine checks if any parallization was done and copies all real and complex entries of $\Epar$ into the argument \code{eparc} by looping over all grid points for $s$, $\psi$ and $\zeta$ coordinate. If \code{nlepar} is set to \code{.false.}, a zero data set will be return.

The subroutine \code{get\_epar} gets called in \code{diagnostic} in the subroutine \code{fill\_buffer} where the new defined field identifier \code{EPAR\_FIELD} form module \code{global} is used. 
\lstinputlisting[language=Fortran, firstline=869, lastline=876]{../gkw/src/diagnostic.f90}
Here, the calculated values for $\Epar$ gets copied from \code{fdisi} (or \code{fdis\_tmp} for parallization) to the variable \code{epar} from the module \code{dist}. In {\gkw}, each diagnostics computes and outputs a distinct physical quantity. \cite{GKWManual}. In \code{diagnos\_mode\_struct} the code gets adapted for the implementation of $\Epar$ and the new field identifier \code{EPAR\_FIELD} by increasing the size of the arrays \code{mode\_struct\_lus}, \code{mode\_struct\_ids}, \code{mode\_struct\_names}, \code{local\_write} and \code{global\_write} by one element. It is worth mentioning that from now on the variabels \code{epar} and \code{eperp} are renamed to \code{ene\_par} and \code{ene\_perp}. After loading the data for $\Epar$ from the variable \code{epar} in a loop for each species $\spec{N}$, grid points in binormal direction $N_\mathrm{mod}$, radial direction $N_x$ and in field direction $N_s$ into the variable \code{epad}. Then, \code{epad} gets normalised by rotating relative to the maximum electrostatic potential $\Phi_1$ in the complex plane for each mode is $1 + 0i$ and saved in parallel data structure. For that, the end of the loop with variable \code{il} will be increased from 8 to 9 and the parallel data structure got adjusted for two additional columns for $\Epar$, i.e. for real and imaginary values. Note that if \code{nlepar} is set to \code{.false.} the variable \code{epad} returns an zero array. Due to this behaviour the testcases 
\begin{itemize}
    \item \code{adiabat\_collisions\_momcon\_ap},
    \item \code{chease\_cf\_modebox},
    \item \code{collisions\_please\_dont\_break\_me} and
    \item \code{zonal\_flow\_sixth\_order\_FD}
\end{itemize}
have to adjusted to contain the two zero columns from $\Epar$ in the file \code{parallel.dat}

Additionally, for $\gaEpar$ the function \code{get\_averaged\_epar} in the module code{fields} gets defined and works as \code{get\_epar}. Here, the function differs between local and global simulations. As defined in Chapter \ref{sub:gyroOperatorLocal} is the gyroaverage of a quantity in a local simulation the product with the zeroth order Besselfunction $J_0$ and the quantity itself, i.e. $\gaEpar = J_0 \Epar$, which gets calculated in \code{get\_averaged\_epar}. In case of a global simulation the subroutine will return the calculated $\gaEpar$ from \code{fdisi} and as in \code{get\_epar} if \code{nlepar} is \code{.false.} a zero data set will be returned. The function \code{get\_averaged\_epar} is listed below for a closer look.

\lstinputlisting[language=Fortran, firstline=114, lastline=140]{../gkw/src/fields.f90}

\newpage

\subsection*{Benchmark of $\Epar$ Field Equation - Linear $\beta$ Scan}
\label{sub:benchmarkFieldEpar}

To benchmark the implementation of Faraday's law with $\Epar$ multiple linear simulations for different plasma beta $\beta$ gets performed. The goal is to extract the linear growth rate $\gamma$ and frequency $\omega$ to compare the result for $\Epar$ with $\Apar$. General a given quantity saved in \code{parallel.dat} gets saved in two columns containing real and imaginary values. The rows are sorted by the species $\Nsp$, bidnormal gird points $\Nmod$, radial grid points $\Nx$ and grid points along the field line $\Ns$ and therefore $\Nsp\Nmod\Nx\Ns$ rows. Data stored in \code{parallel.dat} is defined as
\begin{gather}
    \widehat{L}(s,t) = \exp (\gamma t + i\omega t) \widehat{L}(s)~,
    \label{eq:parallelData}
\end{gather}
where $\widehat{L}(s,t)$ is the calculated data and $\widehat{L}(s)$ is the stored values. \cite{GKWManual} Note that, $\widehat{L}(s,t)$ and $\widehat{L}(s)$ are complex. With Equation (\ref{eq:parallelData}) one can derive the relation between $\FEpar$ and $\FApar$ with Faraday's law [Eq. (\ref{eq:faradayLaw})] as
\begin{gather}
    \begin{aligned}
        \FEpar(s,t) &= - \partial_t \FApar(s,t) \\
        \exp (\gamma t + i\omega t) \FEpar(s) &= - \partial_t \left[\exp(\gamma t + i\omega t) \FApar(s)\right] \\
        \FEpar(s) &= - (\gamma + i\omega) \FApar(s) \\
        \FEpar^\mathrm{R}(s) + i \FEpar^\mathrm{I}(s) &= - (\gamma + i\omega) \left(\FApar^\mathrm{R}(s) + i \FApar^\mathrm{I}(s)\right)
    \end{aligned} \\[0.5cm] 
    \Rightarrow \boxed{
    \begin{aligned}
        \FEpar^\mathrm{R}(s) &= - \gamma \FApar^\mathrm{R}(s) + \omega \FApar^\mathrm{I}(s) \\ 
        \FEpar^\mathrm{I}(s) &= - \omega \FApar^\mathrm{R}(s) - \gamma \FApar^\mathrm{I}(s)   
    \end{aligned}
    } \nonumber
    \label{eq:parallelDataEparEqApar}
\end{gather}
\newpage
\subsection*{Simulation Setup}
For the plasma beta following values are investigated
\begin{gather}
    \beta \in [0.0,~0.2,~0.4,~0.6,~0.8,~1.0,~1.1,~1.2,~1.4,~1.6]\,\%~.
\end{gather}
The values will be set with the parameter \code{beta} in the input file. As base input file the cyclone benchmark case provided by the {\gkw} Team was used. The input file can be found in the {\gkw} repository under \code{doc/input/cyclone}. Here, the input parameter were adjust for linear $\beta$ scan and are displayed in Table \ref{tab:adjustInputparameter}. Additionally following parameter were set
\begin{itemize}
    \item \code{NON\_LINEAR} = \code{.false.} to enable linear simulations, 
    \item \code{nlepar}      = \code{.true.} to enable the calculatation of $\Epar$,
    \item \code{io\_format}  = \code{'hdf5} output data to \code{hdf5} format,
    \item \code{gama\_tol}   = $1 \cdot 10^{-5}$ defines tolerance for linear growth rate $\gamma$,
    \item \code{adiabatic\_electrons} = \code{.false.} to enable kinetic electrons,
    \item \code{mode\_box}   = \code{.false.} deactivates 2D mode grid and
    \item $k_\zeta \rho$     = 0.3 defines \enquote{poloidal} wave vector which corresponds roughly to the position of the maximum of the nonlinear transport spectrum in {\gkw}.
\end{itemize}
\begin{center}
    \centering
    \captionsetup{type=table}
    \begin{tabular}{c c c | c c c c c c c}
        \code{DTIM} & \code{NTIME} & \code{NAVERAGE} & $\Nmod$ & $\Nx$ & $\Ns$ & $\Nvpar$ & $\Nmu$ & $\Nsp$ & \code{nperiod} \\ \hline
        0.01 & 2000 & 100 & 1 & 1 & 288 & 64 & 16 & 2 & 5
    \end{tabular}
    \captionof{table}{Adjusted input parameter for linear $\beta$ scan: \textbf{Variables}}
    \label{tab:adjustInputparameter}
\end{center}
Since the simulation perfroms well on the cluster it was shown that parallelization with OpenMPI works. The result of the linear $\beta$ scan can be seen in Figure \ref{fig:betaScanGVersion}. The obtained data shows good agreement with Ref. \citenum{Pueschel2008} although due to the different normalization scheme, i.e. GENE normalises with speed of sound and {\gkw} normalise by the thermal velocity $\vth$, the values are $\sqrt{2}$ times smaller. Furthermore, one would notice by comparing the beta scan in Ref. \citenum{Pueschel2008} and Figure \ref{fig:betaScanGVersion} that the transition from ion temperature gradient mode (ITG) to trapped electron mode (TEM) and from (TEM) to kinetic balloning mode (KBM) are located at different values of plasma beta $\beta$. This behaviour is due to different values for the wave vector $k_\zeta \rho$ and the resolution of parallel velocity grid $\Nvpar$. %TODO: negativeruler values

\includegraphicsHere{../pictures/evaluation/benchmark/g-version/kthrho0.300_beta0.000-0.016_scan_g-version.pdf}{
    Growth rate $\gamma$ and frequency $\omega$ for different plasma beta $\beta$. Here, (ITG) stands for ion temperature gradient modes, (TEM) for trapping electron modes and (KBM) for kinetic balloning modes.
}{fig:betaScanGVersion}{1.0}

The comparision of the induced electric field $\Epar$ and plasma induction $\Apar$ yields that the implementation of the $\Epar$ field equation was successful. An overall camparison is shown in Figure \ref{fig:fieldComparisionGVersion} and for a more detailed look for different plasma beta values the reader is referred to Appendix \ref{subappend:fieldComparisionGVersion}.

%TODO: Add Performance result

\includegraphicsRotHere{../pictures/evaluation/benchmark/comparison/kthrho0.300_beta0.000-0.016_fields_g-version.pdf}{
    Comparision between real and imaginary part of the induced electric field $\Epar$ and plasma induction $\Apar$ for different plasma beta values for the g-verison of {\gkw}.
}{fig:fieldComparisionGVersion}{0.94}

\newpage